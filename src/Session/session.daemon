#!/bin/bash -vx
#
# Session manager for NoSnips replacement service.
# Usage:
#     session.daemon path/to/nosnips.toml
#
# https://github.com/dbohdan/remarshal is used for reading toml
# jq is used for parsing JSON
#

# set config file:
#
CONFIG="/etc/susi.toml"
source $SUSI_INSTALLATION/bin/toml2env $CONFIG

# load tool funs:
#
source $SUSI_INSTALLATION/src/Tools/funs.sh
source $SUSI_INSTALLATION/src/Session/dialogueManagerActions.sh

# Topics:
#
source $SUSI_INSTALLATION/src/Tools/topics.sh

cd $local_work_directory
# core loop that catches all MQTTs depending on
# state:
#
DOING="no_session"
while true ; do

  setDMtopics
  subscribeSmart $MATCH $TOPICS

  ID="id:$(uuidgen)"    # set request ID for next round.

  # manage timeouts:
  #
  if [[ $MQTT_TOPIC == $TOPIC_TIMEOUT ]] ; then
    if [[ $MQTT_ID == $TIMEOUT_ID ]] &&
       [[ $DOING != "no_session" ]] ; then
      publishSessionEnded "timeout"
      publishHotwordOn
      DOING="no_session"
    fi
  else
    scheduleTimeOut
  fi

  # manage dialogue manager sequences:
  #
  case "$MQTT_TOPIC" in

    $TOPIC_ASR_AUDIO)
      AUDIO="$(extractJSON .audio $MQTT_PAYLOAD)"
      if [[ -z $AUDIO ]] ; then
        publishSessionEnded "error: no audio"
        publishHotwordOn
        DOING="no_session"
      else
        publishAsrTransscribe  # next: wait for STT result
        DOING="wait_for_stt"
      fi
      ;;

    $TOPIC_ASR_TEXT)
      TEXT="$(extractJSON .transscript $MQTT_PAYLOAD)"
      if [[ -z $TEXT ]] ; then
        publishSessionEnded "error: no transscript"
        publishHotwordOn
        DOING="no_session"
      else
        publishNluQuery # next: wait for NLU result
        DOING="wait_for_nlu"
      fi
      ;;

    $TOPIC_NLU_NOT)
      publishSessionEnded "error: NLU failed"
      qndSay "failedNLU"
      publishHotwordOn
      DOING="no_session"
      ;;

    $TOPIC_NLU_PARSED)
      INTENT="$(extractJSON .intent $MQTT_PAYLOAD)"
      publishIntent
      DOING="session_ongoing"
      ;;

    $TOPIC_HOTWORD)
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID
      publishAsrStart # next: wait for audio recording
      DOING="wait_for_asr"
      ;;

    $TOPIC_START_SESSION)
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID

      # check if action or notification or api or command:
      #
      TYPE="$(extractJSON .init.type $MQTT_PAYLOAD)"
      if [[ $TYPE == "action" ]] ; then
        publishAsrStart # next: wait for audio recording
        DOING="wait_for_asr"

      elif [[ $TYPE == "notification" ]] ; then
        TEXT="$(extractJSON .init.text $MQTT_PAYLOAD)"
        publishTTSrequest
        DOING="wait_for_tts"
        NEXT_DOING="end_session"
        PLAY_SITE=$SESSION_SITE_ID

      elif [[ $TYPE == "api" ]] ; then
        INTENT="$(extractJSON .intent $MQTT_PAYLOAD)"
        publishIntent
        DOING="session_ongoing"

      elif [[ $TYPE == "command" ]] ; then
        TEXT="$(extractJSON .init.command $MQTT_PAYLOAD)"
        publishNluQuery
        DOING="wait_for_nlu"

      else  # wrong formatted payload:
        DOING="no_session"
      fi
      ;;

    $TOPIC_TTS_AUDIO)
      AUDIO="$(extractJSON .audio $MQTT_PAYLOAD)"
      if [[ -z $AUDIO ]] ; then
        publishSessionEnded "error: no audio from TTS"
        publishHotwordOn
        DOING="no_session"
      else
        if [[ -z $PLAY_SITE ]] ; then
          PLAY_SITE=$SESSION_SITE_ID
        fi
        publishPlay $PLAY_SITE
        PLAY_SITE=$SESION_SITE_ID
        DOING="playing"
      fi
      ;;

    $TOPIC_TTS_PLAY_FINISHED)
      if [[ $NEXT_DOING == "end_session" ]] ; then
        publishSessionEnded
        publishHotwordOn
        DOING="no_session"
      else
        DOING="session_ongoing"
      fi
      ;;

    $TOPIC_TTS_SAY)
      TEXT="$(extractJSON .text $MQTT_PAYLOAD)"
      PLAY_SITE="$(extractJSON .siteId $MQTT_PAYLOAD)"
      publishTTSrequest
      DOING="wait_for_tts"
      NEXT_DOING="session_ongoing"
      ;;

  esac
done
