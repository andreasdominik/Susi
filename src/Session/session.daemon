#!/bin/bash
#
# Session manager for NoSnips replacement service.
# Usage:
#     session.daemon path/to/nosnips.toml
#
# https://github.com/dbohdan/remarshal is used for reading toml
# jq is used for parsing JSON
#

# set config file:
#
CONFIG="/etc/susi.toml"
source $SUSI_INSTALLATION/bin/toml2env $CONFIG

# load tool funs:
#
source $SUSI_INSTALLATION/src/Tools/funs.sh
source $SUSI_INSTALLATION/src/Session/dialogueManagerActions.sh
source $SUSI_INSTALLATION/src/Tools/topics.sh

# base names for recveived and subm. MQTT message files:
#
MQTT_BASE_NAME="sessionDaemon"
MQTT_COUNTER=0

MQTT_CLIENT_ID="sessionManager-$RANDOM"
MQTT_MESSAGE_PIPE="$session_message_pipe"
# mqtt_subscribe="$mqtt_subscribe --id $MQTT_CLIENT_ID -c"

cd $local_work_directory

# start listener and write to pipe:
#
if [[ -e $MQTT_MESSAGE_PIPE ]] ; then
  rm -f $MQTT_MESSAGE_PIPE
fi
mkfifo $MQTT_MESSAGE_PIPE

# subscribe to all incoming topics:
#
_TOPICS="-t $TOPIC_ASR_AUDIO \
        -t $TOPIC_ASR_TEXT \
        -t $TOPIC_NLU_NOT \
        -t $TOPIC_NLU_PARSED \
        -t $TOPIC_TTS_AUDIO \
        -t $TOPIC_TTS_SAY \
        -t $TOPIC_PLAY \
        -t $TOPIC_PLAY_FINISHED \
        -t $TOPIC_TIMEOUT \
        -t $TOPIC_HOTWORD \
        -t $TOPIC_CONTINUE_SESSION \
        -t $TOPIC_END_SESSION \
        -t $TOPIC_START_SESSION"
TOPICS=$(echo $_TOPICS)

echo $TOPICS
set -xv
$mqtt_subscribe -v $(mqtt_auth) $TOPICS > $MQTT_MESSAGE_PIPE &
set +xv

# set -xv
# core loop that catches all MQTTs depending on
# state:
#
DOING="no_session"
NEXT_DOING="nothing_special"
SESSION_ID="no_session"
LANG=$assistant_language
INTENT_FILTER="[]"

cat $MQTT_MESSAGE_PIPE | while read ONE_MESSAGE ; do

  MQTT_COUNTER=$(($MQTT_COUNTER + 1))
  RECEIVED_BASE="${MQTT_BASE_NAME}-$(printf "%04d" $MQTT_COUNTER)"
  RECEIVED_MQTT="${RECEIVED_BASE}.mqtt"
  RECEIVED_PAYLOAD="${RECEIVED_BASE}.json"
  echo $ONE_MESSAGE > $RECEIVED_MQTT
  parseMQTTfile

  echo ""
  echo "doing: $DOING, session: $SESSION_ID"
  echo -n "MQTT received topic: $MQTT_TOPIC, "
  echo "id: $ID, mqttId: $MQTT_ID"
  echo "next queued topic: ${START_QUEUE[0]}"
  echo "next queued json: ${START_QUEUE[1]}"

  # always manage timeouts if in session:
  #
  if [[ $SESSION_ID != "no_session" ]] ; then
    if [[ $MQTT_TOPIC == $TOPIC_TIMEOUT ]] ; then
      if [[ $MQTT_ID == $TIMEOUT_ID && $MQTT_SESSION_ID == $SESSION_ID ]] ; then
        makeSessionEnd "timeout"
      fi
    else
      scheduleTimeOut
    fi
  fi

  # start new session:
  #
  if [[ $MQTT_TOPIC == $TOPIC_HOTWORD ]] ; then

    # start session or queue the request:
    #
    if [[ $DOING == "no_session" ]] ; then
      nextId
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID
      TYPE=hotword
      # sleep 1
      publishLogSessionStarted
      publishAsrStart # next: wait for audio recording
      DOING="wait_for_asr"
      scheduleTimeOut
    else
      addToQueue
    fi
  fi


   if [[ $MQTT_TOPIC == $TOPIC_START_SESSION ]] ; then

    # start session or queue the request:
    #
    if [[ $DOING == "no_session" ]] ; then
      nextId
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID
      scheduleTimeOut

      # check if action or notification or api or command:
      #
      TYPE="$(extractJSONfile .init.type $RECEIVED_PAYLOAD)"
      publishLogSessionStarted
      if [[ $TYPE == "action" ]] ; then
        extractIntentFilter ".init.intentFilter" $RECEIVED_PAYLOAD
        echo "intentfilter: $INTENT_FILTER"

        TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
        if [[ -z $TEXT ]] ; then
          publishAsrStart # next: wait for audio recording
          DOING="wait_for_asr"
        else
          publishTTSrequest
          PLAY_SITE=$SESSION_SITE_ID
          DOING="wait_for_tts"
          NEXT_DOING="wait_for_asr"
        fi

      elif [[ $TYPE == "notification" ]] ; then
        TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
        extractIntentFilter ".init.intentFilter" $RECEIVED_PAYLOAD
        publishTTSrequest
        DOING="wait_for_tts"
        NEXT_DOING="end_session"
        PLAY_SITE=$SESSION_SITE_ID

      elif [[ $TYPE == "api" ]] ; then
        INTENT="$(extractJSONfile .init.intent $RECEIVED_PAYLOAD)"
        publishIntent ".init.intent"
        scheduleTimeOut # because no other timeout will be issued
        DOING="session_ongoing"

      elif [[ $TYPE == "command" ]] ; then
        TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
        extractIntentFilter ".init.intentFilter" $RECEIVED_PAYLOAD
        publishNluQuery
        DOING="wait_for_nlu"

      else  # wrong formatted payload:
        makeSessionEnd "payload wrong formatted"
      fi
    else
      addToQueue
    fi
  fi

  # a) in the chain only do something if the id matches the request:
  # b) some topics need to match the session id only (continue, end)
  # c) say should work always:
  #
  # a:
  if [[ $MQTT_ID == $ID ]] ; then
    echo "with correct id: $MQTT_TOPIC"
    nextId

    # manage dialogue manager sequences:
    #
    case "$MQTT_TOPIC" in

      $TOPIC_ASR_AUDIO)
        extractJSONfile .audio $RECEIVED_PAYLOAD > $AUDIO_B64
        if [[ ! -s $AUDIO_B64 ]] ; then
          makeSessionEnd "error: no audio"
        else
          publishAsrTransscribe  # next: wait for STT result
          DOING="wait_for_stt"
        fi
        ;;

      $TOPIC_ASR_TEXT)
        TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
        if [[ -z $TEXT || ${#TEXT} -lt 10 ]] ; then
          makeSessionEnd "error: no transscript"
        else
          publishNluQuery
          DOING="wait_for_nlu"
        fi
        ;;

      $TOPIC_NLU_NOT)
        makeSessionEnd "error: NLU failed"
        # qndSay "failedNLU"
        ;;

      $TOPIC_NLU_PARSED)
        publishIntent ""
        INTENT_FILTER="[]"
        DOING="session_ongoing"
        ;;

      $TOPIC_TTS_AUDIO)
        extractJSONfile .audio $RECEIVED_PAYLOAD > $AUDIO_B64
        if [[ -z $AUDIO ]] ; then
          # publishSessionEnded "error: no audio from TTS"
          # publishHotwordOn
          DOING="session_ongoing"
        else
          if [[ -z $PLAY_SITE ]] ; then
            PLAY_SITE=$SESSION_SITE_ID
          fi
          publishPlay $PLAY_SITE
          PLAY_SITE=$SESION_SITE_ID
          DOING="playing"
        fi
        ;;

      # playFinished is more, because a session may end afer play:
      #
      $TOPIC_PLAY_FINISHED)
        echo "NEXT_DOING: $NEXT_DOING"
        if [[ $NEXT_DOING == "end_session" ]] ; then
          makeSessionEnd "regular session end"
        elif [[ $NEXT_DOING == "wait_for_asr" ]] ; then  # continue session
          nextId
          publishAsrStart # next: wait for audio recording
          DOING="wait_for_asr"
        else
          DOING="session_ongoing"
        fi
        NEXT_DOING="noting_special"
        ;;
    esac
  # end only if id matches - now sessionId:
  # b:
  elif [[ $MQTT_SESSION_ID == $SESSION_ID ]] ; then
    echo "with correct sessionId: $MQTT_TOPIC"

    if [[ $MQTT_TOPIC == $TOPIC_END_SESSION ]] ; then
      TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
      nextId
      publishTTSrequest
      DOING="wait_for_tts"
      NEXT_DOING="end_session"
      PLAY_SITE=$SESSION_SITE_ID

    elif [[ $MQTT_TOPIC == $TOPIC_CONTINUE_SESSION ]] ; then
      TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
      extractIntentFilter ".init.intentFilter" $RECEIVED_PAYLOAD
      nextId
      if [[ -z $TEXT ]] ; then
        publishAsrStart # next: wait for audio recording
        DOING="wait_for_asr"
      else
        publishTTSrequest
        PLAY_SITE=$SESSION_SITE_ID
        DOING="wait_for_tts"
        NEXT_DOING="wait_for_asr"
      fi
    fi
  fi

  # say and play always possible:
  #
  if [[ $MQTT_TOPIC == $TOPIC_TTS_SAY ]] ; then
    nextId
    TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
    LANG="$(extractJSONfile .lang $RECEIVED_PAYLOAD)"
    if [[ -z $LANG ]] ; then
      LANG=$assistant_language
    fi
    PLAY_SITE="$(extractJSONfile .siteId $RECEIVED_PAYLOAD)"
    publishTTSrequest
    NEXT_DOING=$DOING
    DOING="wait_for_tts"
  fi

  if [[ $MQTT_TOPIC == $TOPIC_PLAY ]] ; then
    nextId
    extractJSONfile .audio $RECEIVED_PAYLOAD > $AUDIO_B64
    PLAY_SITE="$(extractJSONfile .siteId $RECEIVED_PAYLOAD)"
    publishPlay
    NEXT_DOING=$DOING
    DOING="playing"
  fi

done  # loop read messages from pipe
