#!/bin/bash
#
# Session manager for NoSnips replacement service.
# Usage:
#     session.daemon path/to/nosnips.toml
#
# https://github.com/dbohdan/remarshal is used for reading toml
# jq is used for parsing JSON
#

# set config file:
#
CONFIG="/etc/susi.toml"
source $SUSI_INSTALLATION/bin/toml2env $CONFIG

# load tool funs:
#
source $SUSI_INSTALLATION/src/Tools/funs.sh
source $SUSI_INSTALLATION/src/Session/dialogueManagerActions.sh
source $SUSI_INSTALLATION/src/Tools/topics.sh

# base names for recveived and subm. MQTT message files:
#
MQTT_BASE_NAME="sessionDaemon"
MQTT_COUNTER=0

MQTT_CLIENT_ID="sessionManager-$RANDOM"
MQTT_MESSAGE_PIPE="$MQTT_CLIENT_ID.fifo"
# mqtt_subscribe="$mqtt_subscribe --id $MQTT_CLIENT_ID -c"

cd $local_work_directory

# start listener and write to pipe:
#
if [[ -e $MQTT_MESSAGE_PIPE ]] ; then
  rm -f $MQTT_MESSAGE_PIPE
fi
mkfifo $MQTT_MESSAGE_PIPE

# subscribe to all incoming topics:
#
_TOPICS="-t $TOPIC_ASR_AUDIO \
        -t $TOPIC_ASR_TEXT \
        -t $TOPIC_NLU_NOT \
        -t $TOPIC_NLU_PARSED \
        -t $TOPIC_TTS_AUDIO \
        -t $TOPIC_PLAY_FINISHED \
        -t $TOPIC_TTS_SAY \
        -t $TOPIC_TIMEOUT \
        -t $TOPIC_HOTWORD \
        -t $TOPIC_START_SESSION"
TOPICS=$(echo $_TOPICS)

echo $TOPICS
set -xv
$mqtt_subscribe -v $(mqtt_auth) $TOPICS > $MQTT_MESSAGE_PIPE &
set +xv

# set -xv
# core loop that catches all MQTTs depending on
# state:
#
DOING="no_session"
cat $MQTT_MESSAGE_PIPE | while read ONE_MESSAGE ; do

  MQTT_COUNTER=$(($MQTT_COUNTER + 1))
  RECEIVED_BASE="${MQTT_BASE_NAME}-$(printf "%04d" $MQTT_COUNTER)"
  RECEIVED_MQTT="${RECEIVED_BASE}.mqtt"
  RECEIVED_PAYLOAD="${RECEIVED_BASE}.json"
  echo $ONE_MESSAGE > $RECEIVED_MQTT
  parseMQTTfile

  echo "doing: $DOING"
  echo "MQTT received topic: $MQTT_TOPIC"
  echo "id: $ID, mqttId: $MQTT_ID"

  # always manage timeouts:
  #
  if [[ $MQTT_TOPIC == $TOPIC_TIMEOUT ]] ; then
    if [[ $MQTT_ID == $TIMEOUT_ID ]] &&
       [[ $DOING != "no_session" ]] ; then
      publishSessionEnded "timeout"
      publishHotwordOn
      DOING="no_session"
    fi
  else
    scheduleTimeOut
  fi

  # start new session:
  #
  if [[ $DOING == "no_session" ]] ; then
    if [[ $MQTT_TOPIC == $TOPIC_HOTWORD ]] ; then

      nextId
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID
      TYPE=hotword
      # sleep 1
      publishLogSessionStarted
      publishAsrStart # next: wait for audio recording
      DOING="wait_for_asr"

    elif [[ $MQTT_TOPIC == $TOPIC_START_SESSION ]] ; then

      nextId
      nextSessionId
      SESSION_SITE_ID=$MQTT_SITE_ID

      # check if action or notification or api or command:
      #
      TYPE="$(extractJSONfile .init.type $RECEIVED_PAYLOAD)"
      publishLogSessionStarted
      if [[ $TYPE == "action" ]] ; then
        publishAsrStart # next: wait for audio recording
        DOING="wait_for_asr"

      elif [[ $TYPE == "notification" ]] ; then
        TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
        publishTTSrequest
        DOING="wait_for_tts"
        NEXT_DOING="end_session"
        PLAY_SITE=$SESSION_SITE_ID

      elif [[ $TYPE == "api" ]] ; then
        INTENT="$(extractJSONfile .intent $RECEIVED_PAYLOAD)"
        publishIntent
        DOING="session_ongoing"

      elif [[ $TYPE == "command" ]] ; then
        TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
        publishNluQuery
        DOING="wait_for_nlu"

      else  # wrong formatted payload:
        DOING="no_session"
      fi
    fi

  # a) in the chain only do something if the id matches the request:
  # b) some topics need to match the session id only (continue, end)
  # c) say should work always:
  #
  # a:
  elif [[ $MQTT_ID == $ID ]] ; then
    echo "with correct id: $MQTT_TOPIC"
    nextId

    # manage dialogue manager sequences:
    #
    case "$MQTT_TOPIC" in

      $TOPIC_ASR_AUDIO)
        extractJSONfile .audio $RECEIVED_PAYLOAD > $AUDIO_B64
        if [[ ! -s $AUDIO_B64 ]] ; then
          publishSessionEnded "error: no audio"
          publishHotwordOn
          DOING="no_session"
        else
          publishAsrTransscribe  # next: wait for STT result
          DOING="wait_for_stt"
        fi
        ;;

      $TOPIC_ASR_TEXT)
        TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
        if [[ -z $TEXT || ${#TEXT} -lt 10 ]] ; then
          publishSessionEnded "error: no transscript"
          publishHotwordOn
          DOING="no_session"
        else
          publishNluQuery
          DOING="wait_for_nlu"
        fi
        ;;

      $TOPIC_NLU_NOT)
        publishSessionEnded "error: NLU failed"
        # qndSay "failedNLU"
        publishHotwordOn
        DOING="no_session"
        ;;

      $TOPIC_NLU_PARSED)
        publishIntent
        DOING="session_ongoing"
        ;;

      $TOPIC_TTS_AUDIO)
        extractJSONfile .audio $RECEIVED_PAYLOAD > $AUDIO_B64
        if [[ -z $AUDIO ]] ; then
          # publishSessionEnded "error: no audio from TTS"
          # publishHotwordOn
          DOING="session_ongoing"
        else
          if [[ -z $PLAY_SITE ]] ; then
            PLAY_SITE=$SESSION_SITE_ID
          fi
          publishPlay $PLAY_SITE
          PLAY_SITE=$SESION_SITE_ID
          DOING="playing"
        fi
        ;;

      $TOPIC_PLAY_FINISHED)
        if [[ $NEXT_DOING == "end_session" ]] ; then
          publishSessionEnded
          publishHotwordOn
          DOING="no_session"
        else
          DOING="session_ongoing"
        fi
        ;;
      esac
    # end only if id matches - now sessionId:
    # b:
  elif [[ $MQTT_SESSION_ID == $SESSION_ID ]] ; then
    echo "with correct sessionId: $MQTT_TOPIC"

    if [[ $MQTT_TOPIC == $TOPIC_END_SESSION ]] ; then
      TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
      publishTTSrequest
      DOING="wait_for_tts"
      NEXT_DOING="end_session"
      PLAY_SITE=$SESSION_SITE_ID

    elif [[ $MQTT_TOPIC == $TOPIC_CONTINUE_SESSION ]] ; then
      TEXT="$(extractJSONfile .init.text $RECEIVED_PAYLOAD)"
      publishTTSrequest
      DOING="wait_for_tts"
      NEXT_DOING="wait_for_asr"
      PLAY_SITE=$SESSION_SITE_ID
    fi

    # say is always possible:
    #
  elif [[ $MQTT_TOPIC == $TOPIC_TTS_SAY ]] ; then
    TEXT="$(extractJSONfile .text $RECEIVED_PAYLOAD)"
    PLAY_SITE="$(extractJSONfile .siteId $RECEIVED_PAYLOAD)"
    publishTTSrequest
    NEXT_DOING=$DOING
    DOING="wait_for_tts"
  fi

done  # loop read messages from pipe
