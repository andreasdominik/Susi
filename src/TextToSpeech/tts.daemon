#!/bin/bash -xv
#
# STT service for NoSnips replacement.
# Usage:
#     tts.daemon path/to/nosnips.toml
#     tts.daemon #/etc/nosnips.toml
#
#

# set config path:
#
CONFIG="/etc/susi.toml"
source $SUSI_INSTALLATION/bin/toml2env $CONFIG

# load tool funs:
#
source $SUSI_INSTALLATION/src/Tools/funs.sh
source $SUSI_INSTALLATION/src/Tools/topics.sh

# base names for recveived and subm. MQTT message files:
#
MQTT_BASE_NAME="ttsDaemon"
MQTT_COUNTER=0

cd $local_work_directory

BINARY="$(relDir $tts_binary)"
REFRESH_TOKEN_CMD="$(relDir $google_cloud_refresh_token_cmd)"
CREDS="$(relDir $google_cloud_credentials)"
CACHE="$(relDir $tts_cache)"

while true ; do

  subscribeOnce $TOPIC_TTS_REQUEST

  # extract text to be spoken:
  #
  TEXT="$(extractJSONfile .input $RECEIVED_PAYLOAD)"
  LANG="$(extractJSONfile .lang $RECEIVED_PAYLOAD)"
  if [[ -z $LANG ]] ; then
    LANG="de"
  fi

  # check if a new access token is necessary
  #
  $REFRESH_TOKEN_CMD $CREDS

  # name of audio file, base64-encoded:
  #
  AUDIO_NAME="audio.base64"
  rm -f $AUDIO_NAME

  $BINARY $AUDIO_NAME $LANG $CACHE $TEXT > /dev/null 2>&1

  # generate standardised JSON for Susi
  # and fix if ts is corrupted:
  #
  if [[ ! -e $AUDIO_NAME ]] ; then
    touch $AUDIO_NAME
  fi

  MQTT_COUNTER=$(($MQTT_COUNTER + 1))
  PAYLOAD_FILE="${MQTT_BASE_NAME}-$(printf "%04d" $MQTT_COUNTER).payload"

  echo -n "{
            \"sessionId\": \"$MQTT_SESSION_ID\",
            \"id\": \"$MQTT_ID\",
            \"audio\": \""      >  $PAYLOAD_FILE
  cat $AUDIO_NAME               >> $PAYLOAD_FILE
  echo  "\"  }"                 >> $PAYLOAD_FILE

  publishFile $TOPIC_TTS_AUDIO $PAYLOAD_FILE

done
