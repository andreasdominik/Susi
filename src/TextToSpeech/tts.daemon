#!/bin/bash -xv
#
# STT service for NoSnips replacement.
# Usage:
#     tts.daemon path/to/nosnips.toml
#     tts.daemon #/etc/nosnips.toml
#
#

# set config path:
#
if [[ $# -lt 1 ]] ; then
  CONFIG="/etc/susi.toml"
else
  CONFIG=$1
fi

TOML="$(cat $CONFIG | toml2json)"
BASE_DIR="$(echo $TOML | jq -r .local.base_directory)"

# load tool funs:
#
source $BASE_DIR/src/Tools/funs.sh
source $BASE_DIR/src/Tools/topics.sh

# parse config from toml:
# PUBLISH, SUBSCRIBE, MQTT_PORT, MQTT_HOST,
# BASE_DIR, WORK_DIR, SITE_ID
#
readToml $CONFIG

BINARY="$(extractJSONdir .tts.binary)"
REFRESH_TOKEN_CMD="$(extractJSONdir .google_cloud.refresh_token_cmd)"
CREDS="$(extractJSONdir .google_cloud.credentials)"
CACHE="$(extractJSONdir .tts.cache)"

while true ; do

  subscribeOnce $TOPIC_TTS_REQUEST

  # extract text to be spoken:
  #
  TEXT="$(extractJSON .input $MQTT_PAYLOAD)"
  LANG="$(extractJSON .lang $MQTT_PAYLOAD)"
  if [[ -z $LANG ]] ; then
    LANG="de"
  fi

  # SESSION_ID=$MQTT_SESSION_ID
  # ID=$MQTT_ID

  # check if offline:
  # ${SUSI_DIR}/src/Hardware/Internet/checkservices.sh

  # check if a new access token is necessary
  #
  $REFRESH_TOKEN_CMD $CREDS

  # name of audio file, base64-encoded:
  #
  AUDIO_NAME="audio.b64"
  rm -f $AUDIO_NAME

  $BINARY $AUDIO_NAME $LANG $CACHE $TEXT > /dev/null 2>&1

  # generate standardised JSON for Susi
  # and fix if ts is corrupted:
  #
  if [[ -s $AUDIO_NAME ]] ; then
    AUDIO="$(cat $AUDIO_NAME)"
  else
    AUDIO=""
  fi

  PAYLOAD="{
            \"sessionId\": \"$MQTT_SESSION_ID\",
            \"id\": \"$MQTT_ID\",
            \"siteId\": \"$MQTT_SITE_ID\",
            \"audio\": \"$(cat $AUDIO_NAME)\"
           }"
  publish "$TOPIC_TTS_AUDIO" "$PAYLOAD"

done
