<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Installation · Susi</title><link rel="canonical" href="https://andreasdominik.github.io/Susi/dev/install/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../pages/"><img src="../assets/logo.svg" alt="Susi logo"/></a><div class="docs-package-name"><span class="docs-autofit">Susi</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../pages/">Introduction</a></li><li><a class="tocitem" href="../pages/install/">Installation</a></li><li><a class="tocitem" href="../pages/nlu/">NLU</a></li><li><a class="tocitem" href="../pages/configuration/">Configuration</a></li><li><a class="tocitem" href="../pages/components/">Components</a></li><li><a class="tocitem" href="../pages/payloads/">Payloads</a></li><li><a class="tocitem" href="../pages/topics/">Topics</a></li><li><a class="tocitem" href="../pages/tools/">Tools</a></li><li><a class="tocitem" href="../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Installation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Installation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasdominik/Susi/blob/master/docs/src/install.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Installation-1"><a class="docs-heading-anchor" href="#Installation-1">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-1" title="Permalink"></a></h1><p>This tutorial shows a brief installation of Susi. More configuration and customisation is possible - please read the sections &quot;Configuration file susi.toml&quot; and &quot;demons&quot; for details about alternative configurations.</p><p>Susi may be installed on any linux/unix-like operating system.     Because Susi is build with a minimum of specific implementation major parts of its functionality are taken from existing projects. Therefore bunch of software must be installed before using Susi.</p><p>The tutorial assumes that all indivdual software is installed at <code>/opt/</code>. So the first step is to login as the user which will run the assistant later (such as <code>susi</code>), and create the directory <code>/opt/Susi</code>.</p><pre><code class="language-none">sudo mkdir /opt/Susi
chown susi /opt/Susi
chgrp susi /opt/Susi</code></pre><h2 id="Dependencies-1"><a class="docs-heading-anchor" href="#Dependencies-1">Dependencies</a><a class="docs-heading-anchor-permalink" href="#Dependencies-1" title="Permalink"></a></h2><ul><li><strong>git:</strong> Most of the software nusr be obtained from git repos; therefore git must be installed first:</li></ul><pre><code class="language-none">sudo apt-get install git-core curl coreutils</code></pre><ul><li><p><strong>Google cloud services:</strong> if google services are used for text-to-speech (TTS) or speech-to-text (STT) the required softwate must be set up: Go through Google&#39;s tutorial <a href="https://cloud.google.com/text-to-speech/docs/quickstart-protocol">Quickstart: Using the command line</a>.</p><p>In summary ...</p><ul><li>a Google Cloud Platform Project is needed,</li><li>the Cloud Text-to-Speech API must be enabled and</li><li>the JSON-file with the credentials must be downloaded to <code>/opt/Susi/ApplicationData/Google/Credentials/google-credentials.json</code>     Path and filename may differ - they are later specified in the susi configuration file.</li><li>the path to the credentials file must be made available by an variable. Edit the file <code>.bashrc</code> in the home directory of the user who will later run the assistent (e.g. <code>susi</code>) and add the line:    </li></ul></li></ul><p><code>export GOOGLE_APPLICATION_CREDENTIALS=&quot;/opt/Susi/ApplicationData/Google/Credentials/google-credentials.json&quot;</code>           To check the installation run the following command.       It should print an access token, which can be uses to access the Cloud       Text-to-Speech API:</p><pre><code class="language-none">gcloud auth application-default print-access-token</code></pre><ul><li><p><strong>Mozilla DeepSpeech:</strong> nach hinten! TODO as an alternative to the Google Cloud services Mozilla DeepSpeech can be used. However,</p><ul><li>trained models and language models are only available for English langage</li><li>the quality of transcription seems not to be sufficient for an assistant (at least in my tests - this may differ for other speakers and different hardware).</li></ul><p>Installation is simple and follows the instruction on the website (https://github.com/mozilla/DeepSpeech). The installation can be tested by running deepspeech on the commandline.</p></li></ul><pre><code class="language-none"># prepare:
mkdir /opt/DeepSpeech
cd /opt/DeepSpeech
virtualenv -p python3 ./deepspeech-venv/
source $HOME/tmp/deepspeech-venv/bin/activate

# Install DeepSpeech
pip3 install deepspeech

# Download pre-trained English model and extract
curl -LO https://github.com/mozilla/DeepSpeech/releases/download/v0.6.1/deepspeech-0.6.1-models.tar.gz
tar xvf deepspeech-0.6.1-models.tar.gz

# Download example audio files
curl -LO https://github.com/mozilla/DeepSpeech/releases/download/v0.6.1/audio-0.6.1.tar.gz
tar xvf audio-0.6.1.tar.gz

# Transcribe an audio file
rec -r 16000 lighton.wav

deepspeech --model deepspeech-0.6.1-models/output_graph.pbmm --lm deepspeech-0.6.1-models/lm.binary --trie deepspeech-0.6.1-models/trie --audio lighton.wav</code></pre><ul><li><strong>mosquitto, jq, base64:</strong> mosquitto server and client are nedded to send publish and subscribe to MQTT messages. The package mosquitto provides the MQTT broker and is only necessary for the main installation and not for satellites. MQTT messages are sent as JSON strings. susi uses <code>jq</code> to parse JSON. In order to avoid sending binary files via MQTT, they are base64 encoded. The base64 utility is part of the coreutils:</li></ul><pre><code class="language-none">sudo apt-get install jq mosquitto mosquitto-clients coreutils</code></pre><ul><li><p><strong>Julia:</strong> some components of the system are written in the nice and fast programming laguage Julia. Install the current version from https://www.julialang.org (a good location is <code>/opt/Susi/Julia</code>) by downloading the version for your platform to <code>/opt/Susi/Julia</code>, unpacking and creating a link to <code>/usr/local/bin</code> to make it available (example for 64-bit linux).</p><p>Some Julia packages are needed and can be installed right now:</p></li></ul><pre><code class="language-none">tar xvzf &lt;julia-1.3.1-linux-x86_64.tar.gz&gt;
cd /usr/local/bin
sudo ln -s /opt/Julia/&lt;julia-1.3.1&gt;/bin/julia
julia -e &#39;using Pkg; Pkg.add([&quot;ArgParse&quot;, &quot;JSON&quot;, &quot;StatsBase&quot;]; Pkg.update()&#39;</code></pre><ul><li><p><strong>sox:</strong> the Swiss Army knife of sound processing programs (SoX - Sound eXchange) is used for recording and playing sound. It must be installed on the main installaion and on all satellites. In addition ffmpeg and and libsox-fmt-mp3 might be necessary in order to be able to play all types of audio files.</p><p>After installation sox can be tested with <code>rec firstaudio.wav</code> and <code>play firstaudio.wav</code>:</p><p>Volume gain may be adapted with alsamixer or (x11) pavucontrol.</p></li></ul><pre><code class="language-none">sudo apt-get install sox libsox-fmt-mp3
sudo apt-get install ffmpeg</code></pre><ul><li><p><strong>Snowboy:</strong> the Snowboy hotword detector is used by default for hotword recognition. Snowboy is completely local and allows to create and train own hotwords via a web-interface.    </p><ul><li>download the binaries for the required platform from https://github.com/kitt-ai/snowboy.</li><li>unpack the tar ball to <code>/opt/Snowboy</code></li><li>install the dependencies for the required platform as described in https://github.com/kitt-ai/snowboy/README.md</li></ul><p>After the installation (with the default hotword <code>snowboy</code>) individual hotwords can be created and downloaded into  the directory <code>/opt/Susi/Susi/src/Snowboy/bin/resources</code>.</p><p>Snowboy can be tested like described in the Snowboy docu.</p></li></ul><pre><code class="language-none">mkdir /opt/Snowboy
cd /opt/Snowboy
#
# replace rpi-arm-raspbian-8.0-1.3.0.tar.bz2 with the precompiled
# binaries for the required platform:
cp ~/Downloads/&lt;rpi-arm-raspbian-8.0-1.3.0.tar.bz2&gt; /opt/Snowboy
tar xvf &lt;rpi-arm-raspbian-8.0-1.3.0.tar.bz2&gt;
sudo apt-get install python-pyaudio python3-pyaudio sox</code></pre><ul><li><p><strong>Duckling:</strong> Duckling is used to parse transcribed voice input into time or numbers. There is a web-service available, but it is also possible to install it locally - the demo-program, which is shipped with the installation, already provides a local webserver, sufficcient for our neends. Duckling is written in Haskell, so a  Haskell stack is required.</p><ul><li><p>install <code>stack</code> as described here: https://tech.fpcomplete.com/haskell/get-started.</p></li><li><p>io install Duckling create <code>/opt/Duckling/</code>, clone the GitHub repo https://github.com/facebook/duckling into <code>/opt/Duckling</code> and build the executable (be sure to have a good cup of coffee while it&#39;s compiling).</p><p>It might be necessary to install libpcre before building (the build will fail without). After compilation, run the example-exe. It starts a web-server that can be tested by sending simple requests via cURL:</p></li></ul></li></ul><pre><code class="language-none">git clone https://github.com/facebook/duckling
sudo apt–get install libpcre3 libpcre3–dev
cd ./duckling
stack build

# test:
#
stack exec duckling-example-exe

curl -XPOST http://0.0.0.0:8000/parse --data &#39;locale=en_GB&amp;text=tomorrow at eight&#39;</code></pre><h2 id="Susi-1"><a class="docs-heading-anchor" href="#Susi-1">Susi</a><a class="docs-heading-anchor-permalink" href="#Susi-1" title="Permalink"></a></h2><h3 id="Get-and-install-Susi-1"><a class="docs-heading-anchor" href="#Get-and-install-Susi-1">Get and install Susi</a><a class="docs-heading-anchor-permalink" href="#Get-and-install-Susi-1" title="Permalink"></a></h3><ul><li>Clone Susi from the GitHub repo</li><li>make the installation directory available in the environment</li><li>integrate Snowboy</li><li>make links to the executables</li><li>install and activate systemd service to make susi available as service</li><li>install and edit the configuration file <code>/etc/susi.toml</code></li></ul><p>Before starting the service, the configuration must be adapted to the local installation (see next section for details).</p><pre><code class="language-none"># Susi:
cd /opt/Susi
mkdir /opt/Susi/ApplicationData
mkdir /opt/Susi/Skills
git clone git@github.com:andreasdominik/Susi.git

# add variable to environment:
echo &quot;export SUSI_INSTALLATION=&quot;/opt/Susi/Susi&quot; &gt;&gt; ~/.bashrc

# Snowboy:
# replace rpi-arm-raspbian-8.0-1.3.0.tar.bz2 with the precompiled
# binaries for the required platform:
cp Susi/src/Snowboy/bin/hotword_susi.py /opt/Snowboy/&lt;rpi-arm-raspbian-8.0-1.3.0/&gt;
cp Susi/src/Snowboy/bin/snowboydecoder_susi.py /opt/Snowboy/&lt;rpi-arm-raspbian-8.0-1.3.0/&gt;

# Susi service and execs:
cd /usr/local/bin/:
sudo ln -s /opt/Susi/Susi/bin/susi.watch
sudo ln -s /opt/Susi/Susi/bin/susi
sudo ln -s /opt/Susi/Susi/bin/susi.say
sudo ln -s /opt/Susi/Susi/src/Service/susi.start
sudo ln -s /opt/Susi/Susi/src/Service/susi.stop

sudo cp /opt/Susi/Susi/src/Service/susi.service /etc/systemd/system/

# configuration:
sudo cp /opt/Susi/Susi/etc/susi.toml /etc/susi.toml</code></pre><h3 id="Configure-Susi-1"><a class="docs-heading-anchor" href="#Configure-Susi-1">Configure Susi</a><a class="docs-heading-anchor-permalink" href="#Configure-Susi-1" title="Permalink"></a></h3><p>Susi is configured with the file <code>/etc/susi.toml</code>. Susi consists of several daemons that runs at the main system or on all satellites:</p><ul><li>hotword daemon: Hotword detection (all satellites)</li><li>record daemon: record commands (all satellites)</li><li>play daemon: play a audio file (all satellites)</li><li>STT daemon: transcribe recorded speech (audio) to text (only one)</li><li>TTS daemon: synthesise speech (audio) from text (only one)</li><li>NLU daemon: analyse a transcribed command and create an intent (only one)</li><li>session daemon. the session manager that defines pipelines of actions to be executed when a hotword or other trigger is detected (only one).</li><li>duckling server: the duckling webserver is used to extract time, numbers or ordinals from commands.</li></ul><p><code>susi.toml</code> is a standard toml file. All path definitions can be given as relative or absolute paths: if a path starts with an &quot;/&quot;, it is considered to be an absolute path, if not it is expanded relative to the Susi installation (default: &quot;/opt/Susi/Susi&quot;).</p><p>More information about all entries is given in the file.</p><h4 id="Standard-configuration-1"><a class="docs-heading-anchor" href="#Standard-configuration-1">Standard configuration</a><a class="docs-heading-anchor-permalink" href="#Standard-configuration-1" title="Permalink"></a></h4><p>Most parameters in the configuration file are by default set to resonable values and are self-explaining.</p><ul><li>specify a language in 2-letter-code</li><li>select a name for the assistant</li><li>go through the file and double-check or adapt paths if necessary.</li></ul><h4 id="Configuration-for-all-daemons-1"><a class="docs-heading-anchor" href="#Configuration-for-all-daemons-1">Configuration for all daemons</a><a class="docs-heading-anchor-permalink" href="#Configuration-for-all-daemons-1" title="Permalink"></a></h4><p>All daemons share some config entries:</p><ul><li><code>start = &quot;true&quot;</code> defines if the daemon is started with the susi service or not.</li><li><code>daemoon = &quot;xyz&quot;</code> is the path to the executable that runs the daemon.</li><li><code>binary = &quot;xyz&quot;</code> is the path to the executable that does the job when the daemon is gets a trigger.</li></ul><p>The sections of the susi.toml file are:</p><h4 id="[assistant]-1"><a class="docs-heading-anchor" href="#[assistant]-1">[assistant]</a><a class="docs-heading-anchor-permalink" href="#[assistant]-1" title="Permalink"></a></h4><p>Name and language of the assistant.</p><h4 id="[local]-1"><a class="docs-heading-anchor" href="#[local]-1">[local]</a><a class="docs-heading-anchor-permalink" href="#[local]-1" title="Permalink"></a></h4><p>Work directory to store temporary files and name of the local siteId. Each satellite needs an unique name. If satellite is set to &quot;true&quot;, only hotword, record and play daemon will be started on this site.</p><h4 id="[mqtt]-1"><a class="docs-heading-anchor" href="#[mqtt]-1">[mqtt]</a><a class="docs-heading-anchor-permalink" href="#[mqtt]-1" title="Permalink"></a></h4><p>Host and port definitions for the MQTT broker. If empty, the default &quot;localhost&quot; and port &quot;8883&quot; will be used. For installations with satellites the satellites will use this setting to find the correct MQTT broker.</p><p>User and password will be used by the broker and all clients.</p><p>With the subscribe and publish entries the MQTT client binaries can be specified. Currently only eclipse mosquitto is supported.</p><h4 id="[hotword]-1"><a class="docs-heading-anchor" href="#[hotword]-1">[hotword]</a><a class="docs-heading-anchor-permalink" href="#[hotword]-1" title="Permalink"></a></h4><p>Configuration of the hotword daemon. When the daemon is started, it waits for a MQTT message to toggle on hotword detection.</p><ul><li>The <code>binary</code> must  point to the hotword detector (default: <code>/opt/Snowboy/rpi-arm-raspbian-8.0-1.3.0/hotword_susi.py</code>)</li><li><code>model_path</code> and <code>model</code> define the hotword model to be used.</li><li><code>notification</code> is useful for debugging: if &quot;true&quot;, the specified sound file will be played every time the detector is toggeled on.</li></ul><h4 id="[record]-1"><a class="docs-heading-anchor" href="#[record]-1">[record]</a><a class="docs-heading-anchor-permalink" href="#[record]-1" title="Permalink"></a></h4><p>Configuration of the record daemon.</p><ul><li><code>binary</code> by default points to a script that uses sox to record commands.</li><li><code>recording_limit</code> defines the maximum time to wait for a command</li><li>if <code>notification</code> is set to true, a sound defined by <code>notification_start</code> is played every time recoding starts. If <code>notification_start</code> points to a directory (instead of an audio file), one randomly selected files in the directory will be played.     (if the directory contains speech files, such as &quot;hello&quot;, &quot;how can I help you&quot;, &quot;I am your assistant&quot;, &quot;what can I do for you&quot;, the daemon will play one of these sentences).</li></ul><h4 id="[play]-1"><a class="docs-heading-anchor" href="#[play]-1">[play]</a><a class="docs-heading-anchor-permalink" href="#[play]-1" title="Permalink"></a></h4><p>Configuration of the play daemon.</p><h4 id="[tts]-1"><a class="docs-heading-anchor" href="#[tts]-1">[tts]</a><a class="docs-heading-anchor-permalink" href="#[tts]-1" title="Permalink"></a></h4><p>Configuration of the tts daemon.</p><p>By default, Google TTS is used with caching because the quality of Google&#39;s voices is very good. Caching means that an audio file of every uttered sentence will be stored in the cache. As assistants tend to say the same things again and again (&quot;hello&quot;, &quot;OK&quot;, &quot;I copy&quot;), only a small number calls to the webservice is necessary after some time of operation.</p><h4 id="[stt]-1"><a class="docs-heading-anchor" href="#[stt]-1">[stt]</a><a class="docs-heading-anchor-permalink" href="#[stt]-1" title="Permalink"></a></h4><p>Configuration of the STT daemon. By default Google STT is used because of its very high accuracy and common knowledge. However, it&#39;s no longer local and private.     Mozilla DeepSpeech can be used for English language if installed by uncommenting the respective line. Other services may be included by exchange the <code>binary</code>.</p><h4 id="[nlu]-1"><a class="docs-heading-anchor" href="#[nlu]-1">[nlu]</a><a class="docs-heading-anchor-permalink" href="#[nlu]-1" title="Permalink"></a></h4><p>Configuration of the NLU (natural language understanding) daemon. The default daemon is implemented in Julia and uses Regular Expressions for intent matching and capturing of slots values. sh sus For more details see the NLU section of the docu. The NLU also reads the skill directory from the <code>[skills]</code> section to find skills.</p><h4 id="[tts]-2"><a class="docs-heading-anchor" href="#[tts]-2">[tts]</a><a class="docs-heading-anchor-permalink" href="#[tts]-2" title="Permalink"></a></h4><pre><code class="language-none">insert the correct installation dir to susi.toml
(/opt/Duckling/duckling) with the leading / to enforce
absolute path.</code></pre></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 21 February 2020 16:45">Friday 21 February 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
